# Read YAML Github action

This action reads a .yaml file, and sets one output for every key it has. These outputs can be used in later steps, which allows a yaml file to function as a configuration file within a Github workflow.

Furthermore it supports variables interpolation, using the `$(var)` syntax. This allows for complex dependencies and relationship between keys, enabling great flexibility when creating the yaml file.

It supports hierarchy of nested values, representing the output through dot notation.

It also supports filtering dot notations keys in the output so that a specific keys dynamically can be selected in the github workflow.

Finally, it supports adding dot notations keys delimited with \_ as environment variables.

For more information, check the example below.

## Configuration keys

There are 1 mandatody configuration as 'config' and two optional configurations as 'env-var-prefx' and 'key-path-pattern'

### config

This configuration is mandatory and is the path to the yaml file that action should use as its source configuration.

### env-var-prefix

This configuration is optional and is a prefix to the environment variables generated by the action.

for example if the dot notation key in th eoutput will be like a.b.c.d.x and the value for this config is `myVars` then the environment variable set by the action will be like myVars_a_b_c_d_x .

By omitting this config the action will not generate any environment variable.

### key-path-pattern

This configuration is optional and is a regular expression that filters out keys that matches with the pattern.

It also remove that pattern from the key string, so if the dot notation key is like a.b.c.d.x and the key-path-pattern is ^a\\.b\\. the output key will be c.d.x .

By omitting this config the action will not do any filteration and key string replacement.

## Example usage

Four examples are provided in the [examples](examples) folder.

### Basic config

The config file contains the following keys:

> ```yaml
> namespace: namespace_example
> location: location_example
> environment: dev
>
> resource_group_name: $(namespace)-$(location)-$(environment) # this will be replaced with the variables above
> ```

Note that the key `resource_group_name` uses variable interpolation. The key value will resolve to: `namespace_example-location_example-dev`.

The action reads the yaml file as following:

> ```yaml
> name: read-yaml
>
> on:
>   push:
>   workflow_dispatch:
>
> jobs:
>   read-yaml:
>     runs-on: ubuntu-latest
>     steps:
>       - name: checkout
>         uses: actions/checkout@v4
>
>       - name: read-yaml-file
>         uses: ndelangen/action-read-yaml@1.0.0
>         id: read_action_js
>         with:
>           config: ${{ github.workspace }}/examples/config_example.yaml
>
>       - name: use-yaml-file
>         run: |
>           echo namespace: ${{ steps.read_action_js.outputs['namespace'] }}
>           echo location: ${{ steps.read_action_js.outputs['location'] }}
>           echo environment: ${{ steps.read_action_js.outputs['environment'] }}
>           echo resource_group_name: ${{ steps.read_action_js.outputs['resource_group_name'] }}
> ```

And outputs:

> ```
> namespace: namespace_example
> location: location_example
> environment: dev
> resource_group_name: namespace_example-location_example-dev
> ```

### Nested config

The config file contains the following keys:

> ```yaml
> name: example
> environment:
>   name: example
>   permissions:
>     - name: example
>       permission: read
>     - name: example2
>       permission: write
> deployment:
>   code:
>     source:
>       libs: path/to/libs
>       entry: path/to/entry
> ```

Note that this is contained nested values. The action reads the yaml file in the same way as the example above, and outputs:

> ```
> name: example
> environment.name: example
> environment.permissions.0.name: example
> environment.permissions.0.permission: read
> environment.permissions.1.name: example2
> environment.permissions.1.permission: write
> deployment.code.source.libs: path/to/libs
> deployment.code.source.entry: path/to/entry
> ```

### Environment variable output and filter pattern

The config file contains the following keys:

> ```yaml
> name: example
> environment:
>   name: example
>   permissions:
>     - name: example
>       permission: read
>     - name: example2
>       permission: write
> deployment:
>   code:
>     source:
>       libs: path/to/libs
>       entry: path/to/entry
> ```

The action reads the yaml file as following:

> ```yaml
> name: read-yaml
>
> on:
>   push:
>   workflow_dispatch:
>
> jobs:
>   read-yaml:
>     runs-on: ubuntu-latest
>     steps:
>       - name: checkout
>         uses: actions/checkout@v4
>
>       - name: read-yaml-file-1
>         uses: ehsandanesh/action-read-yaml@env-var-and-filter
>         id: deployments
>         with:
>           config: ${{ github.workspace }}/examples/filter/config_example.yaml
>           # This key is optional, omitting that will cause the action to skip environment variables output generation
>           # This key will be the prefix for the environment variables generated by this action
>           env-var-prefix: myEnv
>           # This RegEx is the pattern that will filter out the dot notation keys and also the pattern itself will be removed from the key name
>           key-path-pattern: ^deployment\.code\.
>
>       - name: use-yaml-file-1
>         run: |
>           echo deployment source libs: ${{ steps.deployments.outputs['source.libs'] }}
>           echo deployment source entry: ${{ steps.deployments.outputs['source.entry'] }}
>           echo
>           env | grep "myEnv_"
>           echo
>           echo deployment source libs: $myEnv_source_libs
>           echo deployment source entry: $myEnv_source_entry
>
>       - name: read-yaml-file-2
>         uses: ehsandanesh/action-read-yaml@env-var-and-filter
>         id: permissions
>         with:
>           config: ${{ github.workspace }}/examples/filter/config_example.yaml
>           env-var-prefix: myEnv
>           key-path-pattern: ^environment\.permissions\.
>
>       - name: use-yaml-file-2
>         run: |
>           echo first permission name: ${{ steps.permissions.outputs['0.name'] }}
>           echo first permission permissions: ${{ steps.permissions.outputs['0.permission'] }}
>           echo second permission name: ${{ steps.permissions.outputs['1.name'] }}
>           echo second permission permissions: ${{ steps.permissions.outputs['1.permission'] }}
>           echo
>           env | grep "myEnv_"
>           echo
>           for i in 0 1
>           do
>             name="myEnv_${i}_name"
>             permission="myEnv_${i}_permission"
>             echo first permission name: $(eval "echo \${$name}")
>             echo first permission permissions: $(eval "echo \${$permission}")
>
>           done
> ```

use-yaml-file-1 outputs:

> ```
> deployment source libs: path/to/libs
> deployment source entry: path/to/entry
>
> myEnv_source_entry=path/to/entry
> myEnv_source_libs=path/to/libs
>
> deployment source libs: path/to/libs
> deployment source entry: path/to/entry
> ```

use-yaml-file-2 outputs:

> ```
> first permission name: example
> first permission permissions: read
> second permission name: example2
> second permission permissions: write
>
> myEnv_0_name=example
> myEnv_source_entry=path/to/entry
> myEnv_source_libs=path/to/libs
> myEnv_1_permission=write
> myEnv_1_name=example2
> myEnv_0_permission=read
>
> first permission name: example
> first permission permissions: read
> first permission name: example2
> first permission permissions: write
> ```
